## bit

### 1. bitSet

`bitset`是 C++标准库中的一个类模板,它用于处理固定大小的位序列.`bitset`提供了一种方便的方式来操作位,包括设置/重置/翻转位等操作.

**数据结构**
`bitset`的内部实现通常是一个或多个无符号整数.每个位都对应一个布尔值:0 表示`false`,1 表示`true`.

**使用场景**
`bitset`通常用于需要进行位操作的场景,例如:

- 位掩码和位字段:你可以使用`bitset`来存储和操作位掩码或位字段.
- 二进制表示:`bitset`可以用于存储和操作二进制数.

**注意事项**
- `bitset`的大小在编译时需要确定,不能在运行时改变.
- `bitset`的索引是从右到左的,也就是说,最右边的位是第 0 位.

**使用示例**

以下是一个使用`bitset`的简单示例:

```cpp
#include <bitset>
#include <iostream>

int main() {
    std::bitset<8> b(42); // 42的二进制表示是00101010
    std::cout << b << '\n'; // 输出00101010
    b.flip(); // 翻转所有位
    std::cout << b << '\n'; // 输出11010101
    b.set(1, 0); // 将第1位设置为0
    std::cout << b << '\n'; // 输出11010100
    return 0;
}
```

在这个示例中,我们创建了一个包含 8 位的`bitset`,然后进行了一些位操作,包括翻转所有位和设置特定位的值.

### 2. bitMap

位图(Bitmap)是一种数据结构,用于有效地存储和操作大量的布尔值(通常是 0 和 1).位图通常用于数据库和图形系统中,但也可以用于任何需要处理大量布尔值的场景.

**数据结构**

位图的基本结构很简单:它是一个一维数组,每个元素都是一个位(0 或 1).位图的大小(即位的数量)通常在创建时确定,并且在位图的生命周期内保持不变.

**使用场景**

位图通常用于以下场景:

- 数据库:位图索引是数据库中常用的一种索引类型,特别是在处理大量数据时.
- 图形系统:在计算机图形中,位图通常用于存储图像数据.
- 内存管理:操作系统中的内存管理系统通常使用位图来跟踪哪些内存块正在使用,哪些是空闲的.

**注意事项**

- 位图的大小通常在创建时确定,不能在运行时改变.
- 位图的索引通常是从 0 开始的,也就是说,最左边的位是第 0 位.
- 位图不支持动态扩展,如果需要处理的布尔值数量超过了位图的大小,你需要创建一个新的更大的位图.

**使用示例**

以下是一个使用位图的简单示例(在 C++中,我们可以使用`std::bitset`或`std::vector<bool>`来实现位图):

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<bool> bitmap(10, false); // 创建一个大小为10的位图
    bitmap[3] = true; // 将第3位设置为true
    std::cout << bitmap[3] << '\n'; // 输出1
    bitmap[3] = false; // 将第3位设置为false
    std::cout << bitmap[3] << '\n'; // 输出0
    return 0;
}
```

在这个示例中,我们创建了一个包含 10 个位的位图,然后进行了一些位操作,包括设置特定位的值和获取特定位的值.

**海量数据的 bitmap 使用原理**
bitmap 算法就是使用一个比特映射一个值,它可以用在整数排序和数据压缩上,因为使用一个比特位去存储一个数,所以它可以大大节省空间.

它的具体过程是:先根据数组中元素最大的数 N 计算需要分配多大的空间.
如果使用 int 型数组的形式来保存的话,一个 int = 4 字节 =4\*8 比特 = 32 比特.也就是一个 int 数可以映射 32 个数据(图 1),然后需要找到最大的数 Max,表示最多需要的位数,所以需要开辟的数组空间为 int a[1+Max/32].
然后需要推导一个整数 a 内如何映射 32 个数据,方法是将待存储的数据模 32,然后将 a 中相应位置的比特置为 1.
依此方法映射每一个元素,待读取的时候扫描每个比特位,遇到值为 1 的就还原该数字.

**BitMap 算法评价**

- 优点:
  1. 运算效率高,不进行比较和移位;
  2. 占用内存少,比如最大的数 MAX=10000000;只需占用内存为 MAX/8=1250000Byte=1.25M.
- 缺点:
  1. 所有的数据不能重复,即不可对重复的数据进行排序.(少量重复数据查找还是可以的,用 2-bitmap).
  2. 所需要的空间随着最大元素的增大而增大,当数据类似(1,1000,10 万)只有 3 个数据的时候,用 bitmap 时间复杂度和空间复杂度相当大,只有当数据比较密集时才有优势.

#### 2.1 bitset 和 bitmap 的区别是什么

`bitset`和`bitmap`都是用于处理位操作的数据结构,但它们之间存在一些关键的区别:

1. **大小**:`bitset`的大小在编译时确定,不能在运行时改变.这意味着你在创建`bitset`时必须知道你需要多少位.相比之下,`bitmap`(例如,使用`std::vector<bool>`实现的`bitmap`)的大小可以在运行时改变,这使得它更加灵活.

2. **用途**:`bitset`通常用于处理较小的位序列,例如,你可能会使用`bitset`来存储和操作一个字节的位.相比之下,`bitmap`通常用于处理大量的位,例如,你可能会使用`bitmap`来实现一个位图索引或存储一个大图像的像素数据.

3. **性能**:由于`bitset`的大小在编译时确定,它可以更有效地使用内存,并且它的所有操作都可以在常数时间内完成.相比之下,`bitmap`(例如,使用`std::vector<bool>`实现的`bitmap`)的操作可能需要线性时间,特别是当你需要改变`bitmap`的大小时.

总的来说,`bitset`和`bitmap`都是有用的工具,你应该根据你的具体需求来选择使用哪一个.

### 3. bloomFilter

布隆过滤器(Bloom Filter)是一种空间效率极高的概率型数据结构,用于测试一个元素是否在一个集合中.它的主要优点是空间效率和查询时间都远超一般的算法,但是它存在一定的误报率.

**数据结构**

布隆过滤器基本上是一个很长的二进制向量(位数组)和一系列随机映射函数(哈希函数).它通过将元素通过多个哈希函数映射到位数组的不同位置,来表示一个元素是否存在.

**使用场景**

布隆过滤器通常用于那些不需要 100%准确率,但需要高效率查询的场景.例如:

- 网络爬虫对 URL 的去重,避免爬取已经爬取过的 URL.
- 垃圾邮件过滤,通过检查邮件的内容是否在已知的垃圾邮件内容的布隆过滤器中,来判断邮件是否为垃圾邮件.

**注意事项**

- 布隆过滤器存在一定的误报率,即它可能会错误地认为一个不存在的元素存在.但是,它不会错误地认为一个存在的元素不存在,这被称为"零假阴性".
- 布隆过滤器的误报率和哈希函数的数量/位数组的大小有关.通常,增加哈希函数的数量和位数组的大小可以降低误报率,但会增加计算和存储的成本.
- 布隆过滤器不支持删除操作.如果需要支持删除操作,可以使用 Counting Bloom Filter 或 Cuckoo Filter 等变种.

**布隆过滤器原理与优点**
布隆过滤器是一个比特向量或者比特数组,它本质上是一种概率型数据结构,用来查找一个元素是否在集合中,支持高效插入和查询某条记录.常作为针对超大数据量下高效查找数据的一种方法.

**它的具体工作过程是这样子的:**
假设布隆过滤器的大小为 m(比特向量的长度为 m),有 k 个哈希函数,它对每个数据用这 k 个哈希函数计算哈希,得到 k 个哈希值,然后将向量中相应的位设为 1.在查询某个数据是否存在的时候,对这个数据用 k 个哈希函数得到 k 个哈希值,再在比特向量中相应的位查找是否为 1,如果某一个相应的位不为 1,那这个数据就肯定不存在.但是如果全找到了,则这个数据有可能存在.

**为什么说有可能存在呢?**
因为不同的数据经过哈希后可能有相同的哈希值,在比特向量上某个位置查找到 1 也可能是由于某个另外的数据映射得到的.

**支持删除操作吗**
目前布隆过滤器只支持插入和查找操作,不支持删除操作,如果要支持删除,就要另外使用一个计数变量,每次将相应的位置为 1 则计数加一,删除则减一.

布隆过滤器中哈希函数的个数需要选择.如果太多则很快所有位都置为 1,如果太少会容易误报.

**布隆过滤器的大小以及哈希函数的个数怎么选择?**
k 为哈希函数个数,m 为布隆过滤器长度,n 为插入的元素个数,p 为误报率
![](fig/布隆过滤器.png)

布隆过滤器处理大规模问题时的持久化,包括内存大小受限/磁盘换入换出问题
