#### 1. 哈希表插入元素算法

- **哈希表**：一种数据结构，通过哈希函数将键映射到数组中的位置。
- **插入元素算法**：计算键的哈希值，将元素插入对应位置，处理冲突（如链地址法、开放地址法）。


# 哈希
哈希冲突的解决算法?(开放地址法和拉链法)一致哈希了解吗?
* memcached一致性哈希
* 概念

  * 散列的概念属于查找,它**不以关键字的比较为基本操作**,采用直接寻址技术.在理想情况下,查找的期望时间为O(1)
  * hash函数就是把任意长的输入字符串变化成固定长的输出字符串的一种函数.输出字符串的长度称为hash函数的位数
  * 散列(Hashing)通过散列函数将要检索的项与索引(散列,散列值)关联起来,生成一种便于搜索的数据结构(散列表)

* 常用哈希构造函数

  * 直接定址法
    * 取关键字或关键字的某个线性函数值为哈希地址:H(key) = key 或 H(key) = a`key + b,其中a和b为常数,这种哈希函数叫做自身函数
    * 注意:由于直接定址所得地址集合和关键字集合的大小相同.因此,**对于不同的关键字不会发生冲突**.但实际中能使用这种哈希函数的情况很少
  * 相乘取整法
    * 首先用关键字key乘上某个常数A(0 < A < 1),并抽取出key*A的小数部分;然后用m乘以该小数后取整
    * 注意:该方法最大的优点是m的选取比除余法要求更低.比如,完全可选择它是2的整数次幂.虽然该方法对任何A的值都适用,但对某些值效果会更好.Knuth建议选取 0.61803^^
  * 平方取中法
    * 取关键字平方后的中间几位为哈希地址
    * 通过平方扩大差别,另外中间几位与乘数的每一位相关,由此产生的散列地址较为均匀.这是一种较常用的构造哈希函数的方法
    * 将一组关键字(0100,0110,1010,1001,0111),平方后得(0010000,0012100,1020100,1002001,0012321),若取表长为1000,则可取中间的三位数作为散列地址集:(100,121,201,020,123)
  * 除留余数法
    * 取关键字被数p除后所得余数为哈希地址:H(key) = key MOD p (p ≤ m)
    * 注意:这是一种最简单,也最常用的构造哈希函数的方法.它**不仅可以对关键字直接取模(MOD),也可在折迭/平方取中等运算之后取模**.值得注意的是,在使用除留余数法时,**对p的选择很重要**.一般情况下可以**选p为质数或不包含小于20的质因素的合数**
  * 随机数法
    * 选择一个随机函数,取关键字的随机函数值为它的哈希地址,即 `H(key) = random (key)`,其中random为随机函数.通常,当关键字长度不等时采用此法构造哈希函数较恰当

* 解决哈希冲突的方法

  * 开放定址法:
    * 就是在发生冲突后,通过某种探测技术,去依次探查其他单元,直到探查到不冲突为止,将元素添加进去
    * 假如是在index的位置发生哈希冲突,那么通常有一下几种探测方式
      * 线性探测法(线性探测再散列):向后依次探测index+1,index+2^位置,看是否冲突,直到不冲突为止,将元素添加进去.
      * 平方探测法:不探测index的后一个位置,而是探测$2^i$位置上时发生冲突,比如探测$2^0$位置上的冲突,接着探测$2^1$位置,依此类推,直至冲突解决
  * 链地址法
    * 链表法就是在发生冲突的地址处,挂一个单向链表,然后所有在该位置冲突的数据,都插入这个链表中.插入数据的方式有多种,可以从链表的尾部向头部依次插入数据,也可以从头部向尾部依次插入数据,也可以依据某种规则在链表的中间插入数据,总之保证链表中的数据的有序性.Java的HashMap类就是采取链表法的处理方案
  * 再哈希法
    * 在发生哈希冲突后,使用另外一个哈希算法产生一个新的地址,直到不发生冲突为止.这个应该很好理解
    * 再哈希法可以有效的避免堆积现象,但是缺点是不能增加了计算时间和哈希算法的数量,而且不能保证在哈希表未满的情况下,总能找到不冲突的地址
  * 建立一个公共溢出区
    * 建立一个基本表,**基本表的大小等于哈希表的大小**.**建立一个溢出表,所有哈希地址的第一个记录都存在基本表中,所有发生冲突的数据,不管哈希算法得到的地址是什么,都放入溢出表中**
    * 但是有一个缺点就是,必须事**先知道哈希表的可能大小,而且溢出表里的数据不能太多,否则影响溢出表的查询效率**.实际上就是要尽量减少冲突

* MD5加密算法

  * MD5是一个安全的散列算法,**输入两个不同的明文不会得到相同的输出值,根据输出值,不能得到原始的明文,即其过程不可逆**;所以要解密MD5没有现成的算法,只能用**穷举法**,把可能出现的明文,用MD5算法散列之后,**把得到的散列值和原始的数据形成一个一对一的映射表**,通过比在表中比破解密码的MD5算法散列值,通过匹配从映射表中找出破解密码所对应的原始明文

* 一致性哈希

  * [详见1](https://blog.csdn.net/cywosp/article/details/23397179/)

  * [详见2](https://www.jianshu.com/p/49e3fbf41b9b)


  * 什么是一致性哈希?
  一致性哈希(Consistent Hashing)是一种特殊的哈希技术,广泛应用于负载均衡中,特别是在分布式系统中.

  在传统的哈希表中,如果哈希函数的大小(即,哈希表的大小)改变,那么几乎所有的键都需要重新哈希.这在分布式系统中是不可接受的,因为这意味着当一个节点加入或离开系统时,所有的数据都需要重新分配.

  一致性哈希通过将每个键和每个节点都映射到一个环形的空间(通常称为哈希环)来解决这个问题.然后,每个键被分配给它在哈希环上顺时针方向上的第一个节点.这样,当一个节点加入或离开系统时,只有一小部分键需要重新分配.

  一致性哈希的主要优点是它可以最小化因节点的加入和离开导致的数据重新分配.此外,它还可以提供良好的负载均衡性能,因为键被均匀地分配给所有的节点.

  * 概念

    * 一致性Hash是一种特殊的Hash算法,由于其均衡性/持久性的映射特点,被广泛的应用于**负载均衡领域和分布式存储**,如nginx和memcached都采用了一致性Hash来作为集群负载均衡的方案
    * 普通的Hash函数最大的作用是散列,或者说是将一系列在形式上具有相似性质的数据,打散成随机的/均匀分布的数据.**不难发现,这样的Hash只要集群的数量N发生变化,之前的所有Hash映射就会全部失效**.如果集群中的每个机器提供的服务没有差别,倒不会产生什么影响,但对于分布式缓存这样的系统而言,**映射全部失效就意味着之前的缓存全部失效,后果将会是灾难性的**.一致性Hash通过构建**环状的Hash空间代替线性Hash空间**的方法解决了这个问题

  * 良好的分布式cahce系统中的一致性hash算法应该满足以下几个方面

    * **平衡性(Balance)**:平衡性是指哈希的结果能够**尽可能分布到所有的缓冲中去**,这样可以使得所有的缓冲空间都得到利用.很多哈希算法都能够满足这一条件
    * **单调性(Monotonicity)**:单调性是指如果**已经有一些内容通过哈希分派到了相应的缓冲中**,又有**新的缓冲区加入到系统中,那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去,而不会被映射到旧的缓冲集合中的其他缓冲区**
    * **分散性(Spread)**:在分布式环境中,终端有可能看不到所有的缓冲,而是只能看到其中的一部分.**当终端希望通过哈希过程将内容映射到缓冲上时,由于不同终端所见的缓冲范围有可能不同,从而导致哈希的结果不一致,最终的结果是相同的内容被不同的终端映射到不同的缓冲区中**.这种情况显然是应该避免的,**因为它导致相同内容被存储到不同缓冲中去,降低了系统存储的效率**.分散性的定义就是上述情况发生的严重程度.好的哈希算法应能够尽量避免不一致的情况发生,也就是尽量降低分散性
    * **负载(Load)**:负载问题实际上是从另一个角度看待分散性问题.**既然不同的终端可能将相同的内容映射到不同的缓冲区中,那么对于一个特定的缓冲区而言,也可能被不同的用户映射为不同的内容**.与分散性一样,这种情况也是应当避免的,因此好的哈希算法应能够尽量**降低缓冲的负荷**
    * **平滑性(Smoothness)**:平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的

  * **原理**

    * 一致性哈希将整个哈希值空间组织成一个虚拟的圆环,如假设某哈希函数$H$的值空间为$0 \sim 2^{32}-1$(即哈希值是一个32位无符号整形),整个哈希空间环如下:整个空间按顺时针方向组织,0和$2^{32}-1$在零点中方向重合

      <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/dhs.png" alt="dhs" style="zoom:80%;" />

    * 下一步**将各个服务器使用Hash进行一次哈希**,具体可以选择服务器的**ip或主机名作为关键字**进行哈希,这样每台机器就能确定其在哈希环上的位置,这里假设将上文中四台服务器使用ip地址哈希后在环空间的位置如下

      <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/dhs_align.jpg" alt="dhs_align" style="zoom:50%;" />

      接下来使用如下算法定位数据访问到相应服务器:**将数据key使用相同的函数Hash计算出哈希值,并确定此数据在环上的位置,从此位置沿环顺时针"行走",第一台遇到的服务器就是其应该定位到的服务器**

    * 例如我们有Object A/Object B/Object C/Object D四个数据对象,经过哈希计算后,在环空间上的位置如下.根据一致性哈希算法,数据A会被定为到Node A上,B被定为到Node B上,C被定为到Node C上,D被定为到Node D上

      <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/dhs_align_.jpg" alt="dhs_align_" style="zoom:50%;" />

  * **一致性哈希算法的容错性和可扩展性**

    * 现假设Node C不幸宕机,可以看到此时对象A/B/D不会受到影响,**只有C对象被重定位到Node D**.一般的,在一致性哈希算法中,**如果一台服务器不可用,则受影响的数据仅仅是此服务器到其环空间中后一台服务器(即沿着顺时针方向行走遇到的第一台服务器)之间数据,其它不会受到影响**

    * 如果在系统中增加一台服务器Node X,如下图所示

      <img src="https://gitee.com/canqchen/cloudimg/raw/master/img/dhs_align_2.jpg" alt="dhs_align_2" style="zoom:50%;" />

      此时对象Object A/B/D不受影响,只有对象C需要重定位到新的Node X .一般的,在一致性哈希算法中,**如果增加一台服务器,则受影响的数据仅仅是新服务器到其环空间中前一台服务器(即沿着逆时针方向行走遇到的第一台服务器)之间数据,其它数据也不会受到影响**