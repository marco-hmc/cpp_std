## 哈希表插入元素算法与哈希冲突解决

* **哈希表**是一种通过哈希函数将键映射到数组索引位置的数据结构。
* **插入元素算法**：计算键的哈希值，找到对应位置插入元素；若发生冲突，则需冲突解决策略。

### 1. 常见哈希函数构造方法

1. **直接定址法**

   * 哈希函数直接取关键字或线性函数值：`H(key) = key` 或 `H(key) = a*key + b`
   * 优点：无冲突
   * 缺点：实际应用少，关键字空间大时不可行

2. **除留余数法**

   * `H(key) = key mod p`，`p`为质数或合适数
   * 最简单、常用

3. **相乘取整法**

   * `H(key) = floor(m * (key*A mod 1))`，其中`0 < A < 1`
   * 适合表长为2的幂，常用`A ≈ 0.61803`

4. **平方取中法**

   * 取关键字平方后中间几位作为哈希值
   * 适合均匀分布

5. **随机数法**

   * 用随机函数映射关键字，适合关键字长度不等情况

### 2. 哈希冲突解决方法

#### 1. 开放定址法

当发生冲突时，按一定探测规则寻找下一个空位插入：

* **线性探测**
  按顺序检查`index+1, index+2, ...`直到空槽

* **平方探测**
  检查位置为`index + 1^2, index + 2^2, ...`，避免聚集问题

* **双重哈希（再哈希法）**
  使用第二个哈希函数决定探测步长，减少冲突堆积

#### 2. 链地址法（拉链法）

* 每个数组槽维护一个链表，冲突元素插入链表中
* 优点：插入删除简单，冲突处理灵活
* Java HashMap即采用此方法

#### 3. 再哈希法

* 发生冲突时，用另一个哈希函数重新计算地址

#### 4. 公共溢出区

* 基本表和溢出表分开存储冲突元素
* 需要预估哈希表大小，溢出表过大影响效率

### 3. 一致性哈希（Consistent Hashing）

#### 3.1 概念

* 设计用于分布式系统的哈希技术，解决节点增减时数据重分布的问题
* 传统哈希表大小变化时，几乎所有键需重新映射
* 一致性哈希将哈希空间组织成一个环（哈希环），键和节点映射到环上
* 键映射到环上顺时针遇到的第一个节点

主要优点：
* **最小化数据重新分布**，节点增减只影响少部分数据
* **良好负载均衡**，键均匀分布到节点

容错性与可扩展性：

* 节点故障时，只影响环上该节点到下一个节点间的数据
* 新节点加入时，只重新分配环上新节点与前一节点间的数据

核心要求：

| 要求                | 含义                        |
| ----------------- | ------------------------- |
| 平衡性(Balance)      | 键尽可能均匀分布到所有节点             |
| 单调性(Monotonicity) | 节点变化时，已分配键尽量保持映射不变        |
| 分散性(Spread)       | 不同客户端哈希结果一致，避免同一键被映射到不同节点 |
| 负载(Load)          | 避免某节点负载过重                 |
| 平滑性(Smoothness)   | 节点或键平滑变动时，哈希结果变化应平滑       |

#### 3.2 一致性哈希工作流程

1. 将所有节点用哈希函数映射到环上（如用IP或主机名做键）
2. 将数据对象用同样哈希函数映射到环上
3. 数据对象分配给环上顺时针方向遇到的第一个节点
