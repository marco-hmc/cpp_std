## 字符编码

### 1. concepts

- **计算机如何存储的？**

计算机存储数据的底层机制基于电信号的有无，以二进制的`0`和`1`来表示信息。多个`0`和`1`的组合可以表示不同的数值，无论是二进制、十六进制还是十进制，本质上都是对这些数值的不同表示形式。然而，计算机要处理文字信息，就需要人为地建立起数字与字符之间的对应关系。

- **字符集的概念**

为了让计算机能够表示文字，人们制定了不同的字符集。字符集就是规定了整数与字符之间映射关系的集合。例如，规定`61`代表字符`a`，`62`代表字符`b`等。常见的字符集有`ASCII`和`Unicode`。`ASCII`字符集主要用于支持英文文本，它的编码范围有限，无法表示中文等其他语言的字符。而`Unicode`字符集则致力于支持全球主流的所有文本，几乎涵盖了世界上所有的字符。Unicode 是一个国际标准，用于为世界上所有的字符、符号和表情符号分配一个唯一的数字。这个数字被称为字符的 Unicode 码点。Unicode 的目标是能够表示所有的写作系统，包括拉丁字母、希腊字母、阿拉伯字母、汉字、象形文字等。 Unicode 标准定义了一系列的字符集，每个字符集包含一组字符和它们对应的码点。

- **Unicode 的存储方式**

字符集仅仅定义了字符与整数的映射，并没有解决字符在计算机中实际存储的问题。以`Unicode`为例，它提供了三种主要的存储方式：

1. **UTF - 32**：采用定长编码方式，每个字符固定使用一个`uint32_t`（即 4 字节）来存储。这种方式简单直接，字符的存储和访问都很方便，每个字符占用的空间相同。但如果处理大量文本，尤其是包含许多常用英文字符的文本时，会浪费较多空间，因为英文字符实际上不需要这么大的存储空间。
2. **UTF - 16**：一个字符通常使用 1 - 2 个`uint16_t`（即 2 - 4 字节）来存储。对于基本多文种平面（BMP）内的字符，大多可以用 1 个`uint16_t`表示；而对于一些不常用的字符，可能需要 2 个`uint16_t`。这种方式在一定程度上兼顾了空间和表示能力，对于许多常见的字符，包括英文字符和部分亚洲语言字符，都能较为高效地存储。例如，一个英文字符用一个`uint16_t`存储，中文、日文等字符在 BMP 内的也用一个`uint16_t`。
3. **UTF - 8**：这是一种广泛使用的变长编码方式，一个字符用 1 - 4 个`uint8_t`（即 1 - 4 字节）存储。它根据字符的使用频率来分配存储空间，常用字符（如英文字符、数字等）用较少的字节存储，而不常用的字符（如一些罕见的符号、生僻字等）则用较多字节。一般情况下，一个英文字符用一个`uint8_t`存储，而中文、日文等字符通常需要三个`uint8_t`。这种方式在存储空间利用上较为高效，尤其适合处理多种语言混合的文本。

- **定长编码与变长编码的选择依据**

之所以会有多种存储方式，是因为不同字符在文本中出现的频率差异很大。如果所有字符出现频率相同，使用`UTF - 32`这样的定长编码是合适的，每个字符消耗相同的空间，便于处理。但在实际应用中，数字和英文字符的出现频率远高于中文、阿拉伯文等字符。为了节省存储空间，采用变长编码，让常用字符占用较少的存储空间，不常用字符占用较多空间，从而在整体上优化存储空间的使用。具体选择哪种编码方式，取决于文本的国际化程度和应用场景对空间与处理效率的权衡。

- **字符编码设计的考量因素**

  - 误码处理:在字符编码设计中，误码是一个重要的考量因素。当数据在存储或传输过程中，可能会出现单个比特（bit）的错误。一个好的编码设计应该尽量减少单个比特错误对其他数据的影响，确保即使出现误码，也不会破坏其他正常字符的数据完整性。例如，某些编码方式通过特定的校验机制或冗余信息，使得在检测到误码时能够进行一定程度的纠正或至少不影响后续字符的解析。

  - 定义域与空间利用:编码的定义域决定了它能够表示的字符范围。一般来说，定义域越大，能够表示的字符种类就越多，但同时也意味着可能需要更多的存储空间来表示每个字符。例如，`UTF - 32`能够直接表示非常广泛的字符范围，但每个字符固定占用 4 字节，相比其他编码方式在存储空间上较为浪费。在设计编码时，需要在满足应用所需字符集的前提下，平衡定义域大小和空间利用效率。

  - 开头结尾标记（变长编码）:对于变长编码，如何准确判断一个字符由几个字节组成是一个关键问题。通常的做法是在编码中添加开头结尾标记符，或者通过特定的编码规则来标识字符的边界。例如，`UTF - 8`通过字节的最高位模式来判断一个字符占用的字节数，从而实现准确的字符解析。这些标记或规则确保了在处理变长编码时，能够正确地识别每个字符的起始和结束位置，避免解析错误。

字符编码的设计是一个复杂的过程，需要综合考虑多种因素，以满足不同应用场景对字符表示、存储和处理的需求。上述只是其中一些重要的考量点，实际的编码设计还涉及到许多其他方面的细节和权衡。

### 3. 编码方案

#### 3.1 ASCII

ASCII（美国信息交换标准代码）是一种广泛使用的字符编码标准。

- **控制字符**：ASCII 编码的前 32 个字符（编码值从 0 到 31）被设定为控制字符。这些字符并非用于显示可见的文本内容，而是主要用于控制设备的操作。例如，换行符（ASCII 值为 10，在编程中通常表示为`\n`）用于指示文本换行，回车符（ASCII 值为 13，通常表示为`\r`）常用于将光标移动到当前行的开头，在早期的电传打字机和终端设备中起到重要的控制作用。
- **可打印字符**：ASCII 编码从 32 到 126 的这 95 个字符是可打印字符，涵盖了英文大小写字母（`a - z`、`A - Z`）、数字（`0 - 9`）、标点符号（如`.,;?!`等）以及一些特殊字符（如`$%&`等）。这些字符构成了英文文本处理的基础，使得计算机能够准确地表示和处理英文书写系统中的各种元素。
- **编码空间拓展**：ASCII 标准最初仅定义了 0 到 127 的字符集，这些字符仅需占用 7 位存储空间。然而，在实际的计算机系统和编码实现中，为了方便存储和处理，通常会使用 8 位（即一个字节）来存储每个字符。这样一来，就多出了 128 到 255 这 128 个编码值的空间。不同的系统和编码标准会利用这个额外的空间来定义更多的字符。例如，在 ISO 8859 - 1（又称 Latin - 1）编码中，128 到 255 这个范围被用于存储西欧语言中的特殊字符，像`á`、`ñ`、`ô`等，以满足这些语言在计算机中的字符表示需求。需要明确的是，这 128 到 255 的范围并不属于 ASCII 标准本身，而是由其他后续的编码标准所定义，并且在不同的编码标准中，这个范围所代表的字符集可能各不相同。

#### 3.2 UTF - 8

UTF - 8 是一种可变长度的字符编码，它在现代计算机系统和网络应用中被广泛使用，具有以下特点：

- **多字节表示**：在 UTF - 8 编码体系下，一个字符可能由 1 到 4 个字节组成。对于多字节表示的字符（即由 2、3 或 4 个字节构成的字符），除了第一个字节外，其余字节的开头两位固定为`10`。这一特性是 UTF - 8 编码用于区分多字节字符中首字节与后续字节的关键标志。例如，当遇到一个字节以`10`开头时，就知道它是某个多字节字符中的后续字节。
- **字符长度判断**：通过观察第一个字节的最高位模式，可以确定该字符的字节长度。如果第一个字节的二进制表示以`110`开头（即`110xxxxx`形式），那么这个字符是两个字节长；若以`1110`开头（`1110xxxx`形式），则该字符为三个字节长；要是以`11110`开头（`11110xxx`形式），该字符就是四个字节长。这种设计使得 UTF - 8 在处理不同字符时能够灵活地分配存储空间，同时又能准确地解析字符。
- **兼容性与适用性**：UTF - 8 编码具有出色的兼容性，它完全兼容 ASCII 编码。这意味着所有的 ASCII 字符在 UTF - 8 编码中仍然以单字节形式表示，编码值与 ASCII 编码完全相同。同时，UTF - 8 能够支持整个 Unicode 标准，从而可以表示世界上几乎所有语言的字符。在实际应用中，如果文本内容主要以英文字符为主，UTF - 8 编码大部分情况下每个字符只需一个字节，在存储空间上具有明显的优势，能够有效节省空间。然而，当处理以非英文字符为主的文本时，尤其是像中文、日文等语言，字符通常会以三字节或者四字节的形式表示。这是因为 UTF - 8 为了实现可变长度编码和字符解析的准确性，在每个字节中使用了一些比特位作为状态位，相对减少了用于表示字符本身的数据位。

#### 3.3 UTF - 16

UTF - 16 也是一种用于表示 Unicode 字符的编码方式，具有以下特性：

- **双字节与四字节表示**：UTF - 16 编码可以使用两个字节或者四个字节来表示一个字符。具体使用哪种长度取决于字符在 Unicode 字符集中的位置。
- **设计考量**：它在一定程度上是针对 UTF - 8 的一些特点进行设计的。UTF - 8 虽然在英文字符为主的场景下节省空间，但对于中文字符等其他语言字符，通常需要三个或四个字节来表示，并且由于控制位的存在，相对减少了数据位的使用。而 UTF - 16 的设计旨在优化这种情况，对于大部分常用的中文字符以及其他语言的常用字符，都可以用两个字节来表示，只有一些不常用的字符才会使用四个字节。这种编码方式在处理包含多种语言字符的文本时，在存储空间和字符处理效率之间提供了一种不同的平衡。虽然具体的编码规则较为复杂，在此不做深入研究，但总体上它为 Unicode 字符的表示提供了一种与 UTF - 8 不同的选择，适用于不同的应用场景。

#### 3.4 UTF - 32

UTF - 32 是一种固定长度的 Unicode 字符编码，其主要特点如下：

- **固定四字节表示**：UTF - 32 统一使用四个字节（32 位）来表示每一个 Unicode 字符。这种固定长度的编码方式使得字符处理变得相对简单直接。
- **字符处理优势**：由于每个字符都占用固定的 4 个字节，在处理字符串时，可以通过简单的索引操作直接访问字符串中的任何字符，无需像处理 UTF - 8 或 UTF - 16 字符串那样进行复杂的字节解析和计算。例如，要访问字符串中的第 n 个字符，只需将字符串的起始地址加上 4 \* n 的偏移量，即可直接定位到该字符的存储位置。这种特性使得 UTF - 32 在需要频繁访问或修改字符串中字符的场景下非常高效，大大简化了字符处理的逻辑。
- **空间与兼容性考量**：UTF - 32 使用的存储空间比 UTF - 8 和 UTF - 16 都要多，因为它为每个字符固定分配了四个字节。所以，当内存空间不是主要限制因素，并且应用程序需要进行大量的字符处理操作时，UTF - 32 可能是一个理想的选择。此外，在一些特定的系统或应用中，为了确保与某些特定的软件或硬件的兼容性，也可能会选择使用 UTF - 32 编码。简单概括，UTF - 32 通过固定长度编码，避免了复杂的字符解析过程，以空间换取了处理的便捷性。

### 4. 字符串类设计需要考虑什么因素？

1. 字符串内部应该使用哪种编码？

不同编码方案各有优劣：
- **ANSI（如ISO - 8859 - 1）**：内存占用少、索引快，但仅支持256个字符，通用性差。
- **GBK、Shift - JIS等本地编码**：支持特定语言多字节字符，然而跨平台兼容性差，locale依赖强。
- **UTF - 8**：国际标准，通用性好且与C字符串兼容，但索引性能差（随机访问需遍历）。
- **UTF - 16**：在亚洲语言和BMP字符集中较平衡，不过英文内容空间浪费，索引复杂（需处理代理项）。
- **UTF - 32**：每个字符固定4字节，支持快速随机访问，但内存开销大，对英文字符串浪费严重。

结论：现代通用字符串建议用UTF - 8，高性能索引或特定语言支持场景可考虑UTF - 16或UTF - 32。C++标准库`std::string`（本质`std::basic_string<char>`）默认不关心编码，编码选择由开发者决定。

1. 字符大小写转换函数应该处理哪些字母？

转换小写为大写时，不同范围处理方式不同：
- **仅拉丁字母**：简单快速，满足多数英文场景。
- **包括希腊字母、西里尔字母、德语/法语变音字符等**：提供更完整的Unicode支持。
- **根据当前locale**：最符合用户语言环境，但依赖locale设置。

建议：提供两个版本，`to_upper_ascii()`仅处理ASCII范围，轻量快速；
`to_upper_locale(locale)` / `to_upper_unicode()`基于locale或完整Unicode表转换。

### 5. `char`, `wchar_t`, `char16_t`, `char32_t`
C/C++ 中字符类型多样，涉及不同编码和平台差异：

| 类型         | 用途            | 编码方式                             | 典型平台大小 |
| ---------- | ------------- | -------------------------------- | ------ |
| `char`     | ASCII/UTF-8   | 编码不定，由源文件决定                      | 1 字节   |
| `wchar_t`  | 宽字符           | Windows: UTF-16/ Linux: UTF-32 | 2/4 字节 |
| `char16_t` | 明确的 UTF-16 字符 | UTF-16                           | 2 字节   |
| `char32_t` | 明确的 UTF-32 字符 | UTF-32                           | 4 字节   |

> **注意**：

* Windows 下 `wchar_t` 是 UTF-16
* Linux/macOS 下 `wchar_t` 通常是 UTF-32
* `char16_t` 和 `char32_t` 是 C++11 引入的，语义明确，推荐用于跨平台 Unicode 字符表示

1. **`char`（常规字符）**
  - **类型大小**：1 字节（8 位）。
  - **常见编码**：ASCII、扩展 ASCII 以及在现代代码中广泛应用的 UTF - 8。
  - **用途**：主要用于处理英文字符、字节流，或者作为 UTF - 8 编码字符串的存储类型。
  - **配套字符串类型**：`std::string`。当源代码以 UTF - 8 格式保存时，`char` 类型的字符串通常直接采用 UTF - 8 编码。这在跨平台开发中极为关键，因为 UTF - 8 是目前最为流行的 Unicode 编码方式。

2. **`wchar_t`（宽字符）**
  - **类型大小**：
      - 在 Windows 平台为 2 字节，采用 **UTF - 16** 编码。
      - 在 Linux/Unix 平台为 4 字节，采用 **UTF - 32** 编码。
  - **用途**：用于处理 Unicode 字符（宽字符），尤其适用于非英文字符集。
  - **配套字符串类型**：`std::wstring`。例如：

  ```cpp
  wchar_t hello[] = L"你好";
  ```
  此处的 `L` 前缀表示该字符串字面量为宽字符类型。编译器会依据所在平台，将其转换为相应编码（UTF - 16 或 UTF - 32）的字符数组，且该编码转换在编译时完成，与源文件的编码格式无关。

  需注意，`wchar_t` 的编码方式依赖于平台，不具备可移植性。因此，在跨平台项目中，建议选用语义更明确的字符类型。

3. **`char16_t` 和 `char32_t`（C++11 引入）**

  为解决 `wchar_t` 因平台而异的问题，C++11 引入了两种明确的 Unicode 字符类型：
  - **`char16_t`**：
      - 大小为 2 字节，固定采用 **UTF - 16** 编码。
      - 对应的字符串字面量前缀为 `u"你好"`。
  - **`char32_t`**：
      - 大小为 4 字节，固定采用 **UTF - 32** 编码。
      - 对应的字符串字面量前缀为 `U"你好"`。

  这两种类型提供了清晰的语义以及一致的跨平台行为，适用于编写对 Unicode 处理要求精确的代码。

4. **`std::string`**
  - **底层类型**：`std::basic_string<char>`。
  - **适用编码**：ASCII、扩展 ASCII 和 UTF - 8。
  - **特点**：
      - 每个字符存储占用 1 字节。
      - 操作高效，且与 C 字符串兼容。
      - 在跨平台使用时表现一致，但编码方式需由程序员自行把控。

  它适用于以 **UTF - 8** 编码存储文本的场景，是现代国际化开发中首选的字符串类型。

5. **`std::wstring`**
  - **底层类型**：`std::basic_string<wchar_t>`。
  - **适用编码**：
      - 在 Windows 平台为 UTF - 16。
      - 在 Unix/Linux 平台为 UTF - 32。
  - **特点**：
      - 支持宽字符的 Unicode 编码。
      - 编码会随平台改变，可能引发跨平台行为不一致的问题。
      - 常用于 Windows API 编程，如 `CreateFileW` 函数。 

### 98. ref

1. https://142857.red/book/unicode/#_4

### 99. quiz

#### 1. char 是有符号的还是无符号的？为什么 char 是在 windows 平台是有符号的？

在主流编程平台上，`char` 的符号属性因编译器和平台而异。

多数平台，包括 Windows 以及大多数类 Unix 系统（如 Linux、macOS），`char` 默认是有符号的（signed），能表示的整数范围是 -128 到 127。然而，在部分平台，像一些嵌入式系统以及特定类 Unix 系统（如基于 ARM、PowerPC 的系统），`char` 默认是无符号的（unsigned），可表示的整数范围为 0 到 255。

这种差异可能引发一些不易察觉的问题。例如，若代码假定 `char` 为有符号类型，而在 `char` 为无符号的平台上运行，就可能出现意外行为。所以，若代码依赖 `char` 的符号属性，最好明确使用 `signed char` 或 `unsigned char`。

在 Windows 平台，`char` 为有符号类型，这主要源于历史原因与兼容性考量。至于为何 `char` 是有符号的，虽确切缘由难以考证，但可做如下推测：
 - **ASCII 编码的满足**：ASCII 编码仅需 0 - 127 的范围，有符号的 `char` 能够满足这一使用需求。
 - **C 语言历史遗留**：`signed char` 可能是 C 语言发展过程中的历史遗留。有符号的设定便于进行字符类型的数值运算，比如，`'b' - 'a'` 表示字符间距离为 1，而 `'a' - 'b'` 则等于 -1 。或许在早期某个版本的 C 语言中依赖这种特性，所以将 `char` 设置为有符号类型。而 Linux 的嵌入式设备受此历史遗留影响相对较小，因此采用 `unsigned char`。 

#### 2. 网络传输数据的时候,为什么 byte 类型都是 unsigned char 的,signed char 可以吗?

在网络传输数据场景下，一般采用 `unsigned char` 来表示字节，主要基于以下几方面原因：
1. **统一性**：`unsigned char` 在任何平台下都固定表示 0 到 255 的整数。这就确保了在不同系统与平台间进行数据传输时，数据的解读方式始终一致。不同平台对数据类型的处理可能存在差异，而 `unsigned char` 的这种统一性能够有效避免因平台不同导致的数据理解偏差。
2. **无符号特性**：网络传输的数据多为二进制形式，并非表示数值，不存在正负之分。使用 `unsigned char` 可规避因符号位引发的混淆。若采用有符号类型，在处理数据时，符号位的存在可能会使数据处理变得复杂，甚至可能导致错误的解读。
3. **兼容性**：众多网络协议以及函数库都默认数据由 `unsigned char` 类型的字节构成。若使用 `signed char`，极有可能引发兼容性问题，导致数据传输与处理无法正常进行。

虽然理论上 `signed char` 也可以用于网络传输,但由于上述原因,实际上几乎所有的网络协议和函数库都使用 `unsigned char` 来表示字节.

### 100. 练习

```cpp
#include <iostream>
using namespace std;

int main() {
  char hello[] = "你好你好你好";
  std::cout << sizeof(hello) << std::endl;
  // 如果你好是通过utf8输入，输出19。
  // 如果你好是通过gbk输入的,输出13
  std::cout << hello << std::endl;

  wchar_t hello_w[] = L"你好你好你好";
  std::cout << sizeof(hello_w) << std::endl;
  // 输出14, 编译器转成了utf16编码。
  // 不管管"你好"输入是以utf8输入，还是其他编码方案输入。

  return 0;
}
```

- **SSO 优化**：短字符串（通常<=15 字符）直接存储在对象内部，避免堆分配